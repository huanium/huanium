\documentclass{article}
\usepackage{physics}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{framed}
\usepackage{authblk}
\usepackage{empheq}
\usepackage{amsfonts}
\usepackage{esint}
\usepackage[makeroom]{cancel}
\usepackage{dsfont}
\usepackage{centernot}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{bigints}
\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{lemma}{Lemma}
\newtheorem{defn}{Definition}[section]
\newtheorem{prop}{Proposition}[section]
\newtheorem{rmk}{Remark}[section]
\newtheorem{thm}{Theorem}[section]
\newtheorem{exmp}{Example}[section]
\newtheorem{prob}{Problem}[section]
\newtheorem{sln}{Solution}[section]
\newtheorem*{prob*}{Problem}
\newtheorem{exer}{Exercise}[section]
\newtheorem*{exer*}{Exercise}
\newtheorem*{sln*}{Solution}
\usepackage{empheq}
\usepackage{tensor}
\usepackage{xcolor}
%\definecolor{colby}{rgb}{0.0, 0.0, 0.5}
\definecolor{MIT}{RGB}{163, 31, 52}
\usepackage[pdftex]{hyperref}
%\hypersetup{colorlinks,urlcolor=colby}
\hypersetup{colorlinks,linkcolor={MIT},citecolor={MIT},urlcolor={MIT}}  
\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}

\usepackage{newpxtext,newpxmath}
\newcommand*\widefbox[1]{\fbox{\hspace{2em}#1\hspace{2em}}}

\newcommand{\p}{\partial}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\lag}{\mathcal{L}}
\newcommand{\nn}{\nonumber}
\newcommand{\ham}{\mathcal{H}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\I}{\mathcal{I}}
\newcommand{\K}{\mathcal{K}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\w}{\omega}
\newcommand{\lam}{\lambda}
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\x}{\xi}

\newcommand{\G}{\mathcal{G}}

\newcommand{\f}[2]{\frac{#1}{#2}}

\newcommand{\ift}{\infty}

\newcommand{\lp}{\left(}
\newcommand{\rp}{\right)}

\newcommand{\lb}{\left[}
\newcommand{\rb}{\right]}

\newcommand{\lc}{\left\{}
\newcommand{\rc}{\right\}}


\newcommand{\V}{\mathbf{V}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\Id}{\mathcal{I}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\Z}{\mathcal{Z}}

%\setcounter{chapter}{-1}


\usepackage{enumitem}



\usepackage{listings}
\captionsetup[lstlisting]{margin=0cm,format=hang,font=small,format=plain,labelfont={bf,up},textfont={it}}
\renewcommand*{\lstlistingname}{Code \textcolor{violet}{\textsl{Mathematica}}}
\definecolor{gris245}{RGB}{245,245,245}
\definecolor{olive}{RGB}{50,140,50}
\definecolor{brun}{RGB}{175,100,80}

%\hypersetup{colorlinks,urlcolor=colby}
\lstset{
	tabsize=4,
	frame=single,
	language=mathematica,
	basicstyle=\scriptsize\ttfamily,
	keywordstyle=\color{black},
	backgroundcolor=\color{gris245},
	commentstyle=\color{gray},
	showstringspaces=false,
	emph={
		r1,
		r2,
		epsilon,epsilon_,
		Newton,Newton_
	},emphstyle={\color{olive}},
	emph={[2]
		L,
		CouleurCourbe,
		PotentielEffectif,
		IdCourbe,
		Courbe
	},emphstyle={[2]\color{blue}},
	emph={[3]r,r_,n,n_},emphstyle={[3]\color{magenta}}
}






\begin{document}
\begin{framed}
\noindent Name: \textbf{Huan Q. Bui}\\
Course: \textbf{8.370 - QC}\\
Problem set: \textbf{\#9}\\
Due: Wednesday, Dec 7, 2022\\
Collaborators/References: Piazza
\end{framed}



\noindent \textbf{1. The SWAP test} \\


\noindent The SWAP test tests whether two pure quantum states $\ket{\phi}$ and $\ket{\psi}$ are the same. Before the measurement in the first qubit is made, the circuit does the following (ignoring normalization):
\begin{align*}
	\ket{+} \ket{\psi} \ket{\phi}  &\to \ket{0}\ket{\psi}\ket{\phi} + \ket{1}\ket{\phi}\ket{\psi}\\
	&\to  \ket{+}\ket{\psi}\ket{\phi}+ \ket{-}\ket{\phi}\ket{\psi}
\end{align*}

\begin{enumerate}[label=(\alph*)]
	\item If $\ket{\phi} = \ket{\psi}$, then the state of the circuit before the measurement is 
	\begin{align*}
		(\ket{+} + \ket{-}) \ket{\psi}\ket{\psi} = \ket{0} \ket{\psi} \ket{\psi}.
	\end{align*}
	So the probability that we observe $\ket{0}$ in the first wire is $\boxed{1}$.
	
	\item The state of the circuit before the measurement is 
	\begin{align*}
		\f{1}{2}\ket{0} \lp \ket{\psi}\ket{\phi} + \ket{\phi}\ket{\psi} \rp + \f{1}{2} \ket{1}\lp \ket{\psi}\ket{\phi} - \ket{\phi}\ket{\psi} \rp.
	\end{align*}
	The probability that we observe $\ket{0}$ in the first wire is 
	\begin{align*}
		\f{1}{4}\lp \bra{\psi}\bra{\phi} + \bra{\phi}\bra{\psi} \rp \lp \ket{\psi}\ket{\phi} + \ket{\phi}\ket{\psi} \rp
		= \f{1}{4}\lp 1 + 1 \rp = \boxed{\f{1}{2}} 
	\end{align*}
	
	\item Suppose we apply the SWAP test with the inputs being two identical density matrices:
	\begin{align*}
		\rho_1 = \rho_2= p \ket{0}\bra{0} + (1-p) \ket{1}\bra{1}.
	\end{align*}
	We can do this problem probabilistically. The initial states of the circuit and associated probabilities are:
	\begin{align*}
		\Pr(\ket{+}\ket{0}\ket{0}) &= p^2 \\
		\Pr(\ket{+}\ket{0}\ket{1}) &= p(1-p) \\
		\Pr(\ket{+}\ket{1}\ket{0}) &= (1-p)p \\  
		\Pr(\ket{+}\ket{1}\ket{1}) &= (1-p)(1-p)
	\end{align*}
	From the previous parts, the probability that we observe $\ket{0}$ on the top wire is 
	\begin{align*}
		p^2 + (1-p)(1-p) + \f{1}{2}\lb p(1-p) + (1-p)p \rb =\boxed{ 1 -p + p^2}.
	\end{align*}
	
\end{enumerate}


\noindent \textbf{2. $kl$-qubit code} \\

\noindent The generalization of the 9-qubit code to a $kl$-qubit code has the codewords:
\begin{align*}
	\ket{0}_L = \f{1}{2^{l/2}} ( |\underbrace{000\dots 0}_{k}\rangle + |\underbrace{111\dots 1}_{k}\rangle )^{\otimes l} \\
	\ket{1}_L = \f{1}{2^{l/2}} ( |\underbrace{000\dots 0}_{k}\rangle - |\underbrace{111\dots 1}_{k}\rangle )^{\otimes l}
\end{align*}
Here $k,l$ are odd numbers. In the case where $k=l=3$, we know that this the code can correct 1 bit error and 1 phase error. To correct the bit errors we have to measure $3\times 2 = 6$ syndrome bits. To measure the phase error we have to measure two extra syndrome bits.\\

In the general setup of the problem, we have $l$ blocks of $k$ qubits. Bit flip errors are detected and corrected within the blocks, while phase flip errors are detected and corrected across the blocks. For each block of $k$ qubits, we have to measure $k-1$ syndrome bits to correct for bit flip errors. For phase flip errors, we measure $l-1$ syndrome bits. We can guess the number of bit flip errors by considering the dimension of the space of measurement solutions, which is $2^{k-1}$. The number of bit flip errors that can be corrected is $(k-1)/2$. Likewise, the number of phase flip errors that can be corrected is $(l-1)/2$.\\





\noindent \textbf{3. Quantum Hamming code}\\

\noindent Given a qubit $\ket{\psi} = \al\ket{0} + \be\ket{1}$. The 7-qubit Hamming encoded version is 
\begin{align*}
	\ket{\psi} \to \al\ket{0_L} + \be\ket{1_L}
\end{align*}
where 
\begin{align*}
	\ket{0_L} &= \f{1}{\sqrt{8}}(\ket{0000000} + \ket{1010101} + \ket{0110011} + \ket{1100110} + \\
	&\quad \ket{0001111}+ \ket{1011010} + \ket{0111100} + \ket{1101001}) \\
	\ket{1_L} &= \f{1}{\sqrt{8}}( \ket{1111111} + \ket{0101010} + \ket{1001100} + \ket{0011001} + \\
	&\quad \ket{1110000} + \ket{0100101} + \ket{1000011} + \ket{0010110})
\end{align*}
as usual. Here, the parity check matrix is (following Nielsen and Chuang's convention):
\begin{align*}
	H = \begin{pmatrix}
		0 & 0 & 0 & 1 & 1 & 1 & 1\\
		0 & 1 & 1 & 0 & 0 & 1 & 1\\
		1 & 0 & 1 & 0 & 1 & 0 & 1 
	\end{pmatrix}.
\end{align*}
It is easy to check that $H$ all 7-bit strings in $\ket{0_L}$ and $\ket{1_L}$ are annihilated by $H$. This means we can do parity check on $\al\ket{0_L} + \be\ket{1_L}$ to find the $\sigma_x$ error on qubit 3. This is because the corrupted state takes the form
\begin{align*}
	\ket{\psi'} = \sigma_{z,6} (\al \ket{0_L + e_3} + \be\ket{1_L+e_3})
\end{align*}


\begin{enumerate}[label=(\alph*)]
	\item Suppose there is a $\sigma_x$ error on qubit 3 and $\sigma_z$ error on qubit 6. Since the 7-qubit Hamming code can correct one bit flip and one phase flip either on one or different qubits, the one-qubit state that we will obtain after error correction is simply $\ket{\psi'} = \ket{\psi} = \al\ket{0} + \be\ket{1}$.
	
	\item Suppose there is a $\sigma_x$ error on qubit 3 and $\sigma_y$ error on qubit 6. Consider a codeword in the CSS code of the form $\ket{x+C_2}$. Then the error modifies this codeword as 
	\begin{align*}
		\ket{x+C_2} = \f{1}{\sqrt{C_2}} \sum_{y\in C_2} \ket{x+y} \to \f{1}{\sqrt{C_2}} \sum_{y\in C_2} (-1)^{(x+y)+e_6} \ket{x+y + e_1+e_6}
	\end{align*}
	with an overall global phase which we ignore, since $\sigma_y \propto \sigma_x\sigma_z$. Now, when we do parity check on $\ket{x+y+e_1+e_2}$, we get
	\begin{align*}
		H(e_1+e_6) = \begin{pmatrix}
			0 & 0 & 0 & 1 & 1 & 1 & 1\\
			0 & 1 & 1 & 0 & 0 & 1 & 1\\
			1 & 0 & 1 & 0 & 1 & 0 & 1 
		\end{pmatrix} \begin{pmatrix}
		1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 1 \\ 0
	\end{pmatrix} = \begin{pmatrix}
	1 \\ 1 \\ 1
\end{pmatrix} = He_7.
	\end{align*}
So, the error correcting code will act as if there is a single phase flip error on qubit 6 and a bit flip error on qubit 7 and wrongly correct on those. Because of this, in the end the effect of the bit flip correct will be to add $e_1+e_6+e_7$ to the data. Because $e_1+e_6+e_7$ is an odd-weight Hamming codeword, this will induce a flip of the encoded qubit: $\ket{0_L} \leftrightarrow \ket{1_L}$. On the other hand, the phase flip will be correctly fixed. Therefore, in the end, the decoded qubit will be 
\begin{align*}
	\ket{\psi'} = \be\ket{0} +  \al \ket{1}.
\end{align*}
\end{enumerate}


\noindent \textbf{4. CSS code with distance 2}

\begin{enumerate}[label=(\alph*)]
	\item We are given a CSS code $CSS(C_1,C_2)$ where
	\begin{align*}
		C_1 = \{ 0000,0011,0101,1001,0110,1010,1100,1111  \} \quad\quad C_2 = \{ 0000, 1111 \}
	\end{align*}
	
	The dimension of $CSS(C_1,C_2)$ is $\abs{C_1}/\abs{C_1} = 8/2 = 4$. The $CSS(C_1, C_2)$ is defined by 
	\begin{align*}
		CSS(C_1, C_2) =  \{ \ket{x+C_2}  \vert x\in C_1 \}.
	\end{align*}
	By inspection, we see that
	\begin{align*}
		CSS(C_1,C_2) = \text{span}\{ \ket{0000+C_2} , \ket{0011+C_2} , \ket{0101+C_2} , \ket{1001+C_2}   \}.
	\end{align*}
	
	
	\item Suppose we apply a $\sigma_x$ to qubits 1 and 2 of this code. Then the we have 
	\begin{align*}
		CSS(C_1,C_2) \to \text{span} \{ \ket{1100+C_2} , \ket{1111+C_2} , \ket{1001+C_2} , \ket{0101+C_2}   \} = CSS(C_1,C_2).
	\end{align*}
	So, this operation takes codewords to states in the code. Labeling the codewords as 
	\begin{align*}
		 \ket{0000+C_2} , \ket{0011+C_2} , \ket{0101+C_2} , \ket{1001+C_2}    =  \ket{a}, \ket{b}, \ket{c}, \ket{d} .
	\end{align*}
	we see that applying $\sigma_x$ on qubits 1 and 2 does the following:
	\begin{align*}
		\ket{a} \to \ket{b} \quad \ket{b} \to \ket{a} \quad \ket{c} \to \ket{d} \quad \ket{d} \to \ket{c}.
	\end{align*}
	
	
	\item Since $\sigma_z$ does nothing but change the phases on the basis states of the CSS code, the vector space spanned by the transformed states still remains the same. Because of this, this operation also takes codewords in $CSS(C_1, C_2)$ to codewords in $CSS(C_1, C_2)$. Under this operation, the four basis codewords are mapped to themselves, with potentially a phase flip:
	\begin{align*}
		\ket{a} \to \ket{a} \quad \ket{b} \to \ket{b} \quad \ket{c} \to - \ket{c} \quad \ket{d} \to -\ket{d}
	\end{align*}
	
	\item Now suppose we apply $H$ to all four qubits. To answer this question we can be explicit and write down what happens to all the basis states. But we can also obtain a solution as follows. The CSS code above is spanned by 
	\begin{align*}
		\{ \ket{0000} + \ket{1111}, \ket{0011}+\ket{1100} , \ket{0101} + \ket{1100}, \ket{1001} + \ket{0110}   \}
	\end{align*}
	After applying $H^{\otimes 4}$, the four codewords are transformed to
	\begin{align*}
		\{ \ket{++++} + \ket{----}, \ket{++--}+\ket{--++} , \ket{+-+-} + \ket{--++}, \ket{+--+} + \ket{+--+}   \}
	\end{align*}
	Is the span of these states the CSS code? To this end, we consider the components $\ket{0000}, \ket{0011}, \ket{0101}, \ket{1001}$. It is not difficult to see that for each of these components, each of the resulting states also has $\ket{1111}, \ket{1100}, \ket{1010}$, and $\ket{0110}$ respectively. Moreover, there are no components with an odd number of 1's, since the amplitudes for these components cancel in the expansion of the states from the $+,-$ basis into the $0,1$ basis. As a result, the operation $H^{\otimes 4}$ also take the four codewords to states in the code. In particular, 
	\begin{align*}
		\ket{a} \to \ket{a}+\ket{b}+\ket{c}+\ket{d}\\
		\ket{b} \to \ket{a}+\ket{b}-\ket{c}-\ket{d}\\ 
		\ket{c} \to \ket{a}-\ket{b}+\ket{c}-\ket{d}\\
		\ket{d} \to \ket{a}-\ket{b}-\ket{c}+\ket{d}
	\end{align*} 
\end{enumerate}




\end{document}











